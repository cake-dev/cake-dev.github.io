<!DOCTYPE html>
<html>

<head>
    <title>Map Example</title>
    <style>
        text {
            font-family: Verdana, Geneva, Tahoma, sans-serif
        }

        .message {
            font-size: 2em;
            text-align: center;
        }

        path {
            fill: none;
            stroke-width: 1px;
            stroke: #222;
        }

        .grat {
            stroke: #222;
            stroke-dasharray: 4px;
            stroke-width: 1px;
            opacity: .5
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v0.3.min.js"></script>
</head>

<body>
    <div class="message">D3 Map</div>
    <svg id="viz" width="1000" height="800"></svg>
</body>
<script>

    function create_svg_border(svg, h, w) {
        svg.attr('border', 1);
        svg.append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("height", h)
            .attr("width", w)
            .style("stroke", "black")
            .style("fill", "none")
            .style("stroke-width", 1);
    }


    // {
    //     let d = {
    //         'lon': -83.903347,
    //         'lat': 38.769315
    //     };
    //     let svg = d3.select("svg");
    //     let width = parseInt(svg.attr("width"));
    //     let height = parseInt(svg.attr("height"));

    //     create_svg_border(svg, height, width);

    //     // In order to convert lat / lon (spherical!) coordinates to fit in the 2D
    //     // coordinate system of our screen, we need to create a projection function:
    //     let projection = d3.geoAlbersUsa(); // a USA-specific projection (that deals with Hawaii / Alaska)
    //     projection.translate([width / 2, height / 2]); // this centers the map in our SVG element

    //     let point = projection([d.lon, d.lat]);
    //     console.log("Original positions:");
    //     console.log(d);
    //     console.log("Projected positions: " + point);
    //     svg.append('text').text('X').datum(point).attr('x', d => d[0]).attr('y', d => d[1]).attr('fill', 'purple');
    // }


    createMap = async function () {

        //Control variables here
        var add_cities = false

        let svg = d3.select("#viz");
        let width = parseInt(svg.attr("width"));
        let height = parseInt(svg.attr("height"));

        create_svg_border(svg, height, width);

        svg.append("g").attr("id", "mapLayer");
        svg.append("g").attr("id", "pointLayer");
        d3.select("#mapLayer").append("text").text("US Map").attr("x", 10).attr("y", 20);

        // In order to convert lat / lon (spherical!) coordinates to fit in the 2D
        // coordinate system of our screen, we need to create a projection function:

        let projection = d3.geoAlbersUsa()      // a USA-specific projection (that deals with Hawaii / Alaska)
            .translate([width / 1.2, height / 2]) // this centers the map in our SVG element
            .scale([1600]);                     // this specifies how much to zoom

        // This converts the projected lat/lon coordinates into an SVG path string
        let path = d3.geoPath()
            .projection(projection);



        // Load in states GeoJSON data    
        let us_json = await d3.json("Data/us-states.json");
        let west_us_json = await d3.json("Data/western_us.geojson");

        // load point data
        let um_oval = await d3.json("Data/um_oval_point.geojson");
        let smile_points = await d3.json("Data/smile-points.geojson");
        let us_cities = await d3.csv("Data/us-cities.csv");
        let fire_locations = await d3.json("Data/fires_1985.geojson");

        // Bind data and create one path per GeoJSON feature
        var us_paths = d3.select("#mapLayer").selectAll("path")
            .data(west_us_json.features)
            .join("path")
            // use d attribute to define the path
            .attr("d", path)
            .style("fill", "none");


        // create points object and add to map
        let um_point = d3.select("#pointLayer").selectAll("circle")
            .data(um_oval.features)

        let smile = d3.select("#pointLayer").selectAll("circle")
            .data(smile_points.features)

        let cities = d3.select("#pointLayer").selectAll("circle")
            .data(us_cities)

        let fires = d3.select("#pointLayer").selectAll("circle")
            .data(fire_locations.features)

        um_point
            .join("circle")
            .attr("cx", d => (projection(d.geometry.coordinates)[0]))
            .attr("cy", d => (projection(d.geometry.coordinates)[1]))
            .attr("r", 2)
            .attr("fill", "red");

        var tooltip = d3.select("body")
            .append("div")
            .classed(".tooltip", true)
            .style("position", "absolute")
            .style("z-index", "10")
            .style("visibility", "hidden")
            .style("background", "#ffffff")
            .text("a simple tooltip");

        var color_scale = d3.scaleLinear()
            .domain([us_cities.length - us_cities.length + 1, us_cities.length])
            .range(["#00ff00", "#ff0000"]);

        var c_scale = d3.scaleSequential()
            .domain([us_cities.length - us_cities.length + 1, us_cities.length])
            .interpolator(d3.interpolateViridis);

        var fire_colors = d3.scaleThreshold()
            .domain([500, 1000, 5000])
            .range(["#ffffff", "#ffff00", "#ffcc00", "#ff9900", "#ff6600", "#ff3300", "#ff0000"]);


        const mouseover = (event, d) => {
            tooltip.style("visibility", "visible");
        };

        const mousemove = (event, d) => {
            tooltip
                .style("top", (event.pageY - 10) + "px")
                .style("left", (event.pageX + 10) + "px")
                .text(d.place + " Rank: " + parseInt(d.rank) + " Population: " + parseInt(d.population));
        };

        const mouseleave = (event, d) => {
            tooltip.style("visibility", "hidden");
        };

        fires
            .join("circle")
            .attr("cx", d => (projection(d.geometry.coordinates)[0]))
            .attr("cy", d => (projection(d.geometry.coordinates)[1]))
            .attr("r", d => Math.sqrt(parseInt(d.properties.BurnBndAc) * .0005))
            .attr("fill", d => fire_colors(d.properties.BurnBndAc));




        if (add_cities) {
            cities
                .join("circle")
                .attr("cx", d => (projection([d.lon, d.lat])[0]))
                .attr("cy", d => (projection([d.lon, d.lat])[1]))
                .attr("r", d => Math.sqrt(parseInt(d.population) * .00003))
                .attr("fill", d => c_scale(d.rank))
                .attr("opacity", .8)
                .on("mouseover", event => {
                    tooltip.style("visibility", "visible");
                })
                .on("mousemove", (event, d) => {
                    tooltip
                        .style("top", (event.pageY - 10) + "px")
                        .style("left", (event.pageX + 10) + "px")
                        .text(d.place + " Rank: " + parseInt(d.rank) + " Population: " + parseInt(d.population));
                })
                .on("mouseleave", mouseleave);
        }

        // .on("mouseover", function (d) {
        //     d3.select(this).attr("r", d => Math.sqrt(parseInt(d.population) * .00003) * 2);
        //     console.log(d.place)
        //     // tooltip.text(d.place + " Rank: " + parseInt(d.rank) + " Population: " + parseInt(d.population));
        //     // console.log(d);
        //     // return tooltip.style("visibility", "visible");
        // })
        // .on("mousemove", function () {
        //     // return tooltip.style("top", (event.pageY - 10) + "px").style("left", (event.pageX + 10) + "px");
        // })
        // .on("mouseout", function () {
        //     d3.select(this).attr("r", d => Math.sqrt(parseInt(d.population) * .00003));
        //     // return tooltip.style("visibility", "hidden");
        // });



        //this also works
        // d3.select("#pointLayer").selectAll("circle")
        //     .data(um_oval.features)
        //     .join("circle")
        //     .attr("cx", d => (projection(d.geometry.coordinates)[0]))
        //     .attr("cy", d => (projection(d.geometry.coordinates)[1]))
        //     .attr("r", 100)
        //     .attr("fill", "red");

        // alternate method to put point on map as path, but its just a circle idk how to change any properties of it
        // points = d3.select("#pointLayer").selectAll("path")
        //     .data(um_oval.features)
        //     .join("path")
        //     // use d attribute to define the path
        //     .attr("d", path);

    }

    async function main() {
        await createMap();
    }

    main();

</script>


</html>